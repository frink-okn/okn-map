# OKN Map Analysis Scripts

This directory contains scripts for analyzing class usage patterns across Proto-OKN T1 graphs.

## Overview

These scripts analyze the relationship between:
- **Defined classes**: Classes declared in each graph's schema (LinkML ClassDefinitions)
- **Used classes**: Classes that actually have instances/data in each graph (from usage statistics)

For each T1 graph, the analysis identifies three categories:
1. **Both defined AND used** - Internal classes with actual data
2. **Defined but NOT used** - Schema definitions with no instances
3. **Used but NOT defined** - External classes from other graphs

## Files

- `run_queries.sh` - Runs SPARQL queries against the triple store
- `analyze_class_usage.py` - Analyzes query results and generates report
- `defined_classes.xml` - Output from Query 1 (generated by run_queries.sh)
- `used_classes.xml` - Output from Query 2 (generated by run_queries.sh)

## Usage

### Prerequisites

The backend triple store must be running:
```bash
cd ../docker-backend
docker run -p 8000:8000 okn-triplestore
# or
rdflib-endpoint serve --port 8000 *.ttl
```

### Running the Analysis

1. **Run the SPARQL queries** to extract data:
   ```bash
   ./run_queries.sh
   ```

   This queries the triple store at `http://localhost:8000` (configurable via `SPARQL_ENDPOINT` environment variable):
   ```bash
   SPARQL_ENDPOINT=http://different-host:8000 ./run_queries.sh
   ```

2. **Run the analysis** to process results:
   ```bash
   python3 analyze_class_usage.py
   ```

   Or run both steps together:
   ```bash
   ./run_queries.sh && python3 analyze_class_usage.py
   ```

## Output

The analysis generates:

### Detailed Per-Graph Report
For each graph, shows:
- Total counts for defined/used classes
- Examples of each category (up to 5 per category)
- Instance counts for used classes

Example:
```
SPOKE
--------------------------------------------------------------------------------
  Total defined classes: 6
  Total used classes: 6
  Both defined AND used (internal): 6
  Defined but NOT used: 0
  Used but NOT defined (external): 0

  Both defined and used (6):
    - neo4j://graph.schema#Organism (count: 321442)
    - neo4j://graph.schema#Location (count: 106067)
    ...
```

### Summary Table
Aggregate statistics across all T1 graphs:
```
Graph                             Def   Used   Both  Def!Use  Use!Def
--------------------------------------------------------------------------------
BioBricks ICE                       9      9      9        0        0
SPOKE                               6      6      6        0        0
DREAM-KG                            0     16      0        0       16
Rural Resilience KG                70     10     10       60        0
...
--------------------------------------------------------------------------------
TOTAL                            1192    787    703      489       84
```

**Legend:**
- `Def` = Classes defined in this graph
- `Used` = Classes with usage counts in this graph
- `Both` = Classes both defined AND used (internal usage)
- `Def!Use` = Classes defined but NOT used (no instances)
- `Use!Def` = Classes used but NOT defined (external classes)

## Key Findings

Based on current data:
- **703 classes** across all graphs are both defined and used (internal usage)
- **489 classes** are defined but have no instances (potentially unused schema elements)
- **84 classes** are external dependencies (used from other graphs)

### Notable Patterns

**Perfect internal usage** (all defined classes are used):
- BioBricks ICE, Neighborhood Information KG, SCALES, SPOKE

**High unused definitions**:
- Rural Resilience KG: 86% unused (60/70)
- SUDOKN: 46% unused (365/796)

**Primarily external classes**:
- DREAM-KG: 100% external (0 defined, 16 used)
- UF-OKN: Mostly external (1 defined unused, 5 external)

## SPARQL Queries

### Query 1: Defined Classes
```sparql
SELECT ?graph ?graphLabel ?class ?classLabel ?classUri WHERE {
  ?graph dct:isPartOf okn:proto-okn ;
         a linkml:SchemaDefinition .
  ?class a linkml:ClassDefinition ;
         skos:inScheme ?graph ;
         linkml:class_uri ?classUri .
  optional { ?graph dct:title ?graphLabel }
  optional { ?class dct:title ?classLabel }
}
```

### Query 2: Used Classes
```sparql
SELECT ?graph ?graphLabel ?classUri ?count WHERE {
  ?graph dct:isPartOf okn:proto-okn ;
         a linkml:SchemaDefinition .
  ?graph linkml:annotations [
    linkml:tag okns:counts ;
    skos:example/linkml:classes/skos:example [ ?classUri ?s ]
  ] .
  optional { ?graph dct:title ?graphLabel }
  ?s ?p ?count .
  filter(?p = skos:example)
}
```

## Technical Notes

- The analysis uses set operations to categorize classes:
  - `both = defined âˆ© used`
  - `defined_not_used = defined - used`
  - `used_not_defined = used - defined`

- Classes are identified by their `linkml:class_uri` (the actual URI used in data), not by the ClassDefinition URI in the schema

- The scripts expect XML format SPARQL results (default from rdflib-endpoint)
