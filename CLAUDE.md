# OKN Map - Technical Documentation

This document describes the architecture, data model, queries, and setup for the OKN Map project.

## Overview

The OKN Map is a visualization tool for exploring the Prototype Open Knowledge Network (Proto-OKN). It displays a **metagraph** - metadata about knowledge graphs rather than the graphs themselves. Each graph's structure (schema), classes, properties, and relationships to other graphs are visualized interactively.

## Architecture

### Backend: Triple Store
- **Technology**: `rdflib-endpoint` - a Python-based SPARQL server
- **Data Format**: RDF/Turtle (.ttl files)
- **Endpoint**: `http://localhost:8000` (GET requests with query parameter)
- **Total Triples**: ~586,353 triples loaded from all TTL files

### Frontend: Vue.js Web Application
- **Framework**: Vue 3 + Vite
- **Visualization**: Cytoscape.js (graph visualization library)
- **SPARQL Client**: `fetch-sparql-endpoint` (SparqlEndpointFetcher)
- **Dev Server**: `http://localhost:5173/okn-map/`
- **Base Path**: `/okn-map/` (configured in vite.config.ts)

## Data Structure

### TTL Files in docker-backend/

1. **Theme 1 (T1) Graphs** - Individual knowledge graphs from the OKN project:
   - `spoke.ttl` - SPOKE (health/biology)
   - `biobricks-ice.ttl` - BioBricks-ICE
   - `dreamkg.ttl` - DREAM-KG (justice)
   - `nikg.ttl` - Neighborhood Information KG
   - `ruralkg.ttl` - Rural-KG
   - `scales.ttl` - SCALES
   - `securechainkg.ttl` - Secure Chain (manufacturing)
   - `sudokn.ttl` - SUD-OKN
   - And others...

2. **External Ontologies** - Foundational ontologies that T1 graphs depend on:
   - `foaf.ttl` - Friend of a Friend
   - `dc.ttl` - Dublin Core
   - `owl-rdf-rdfs.ttl` - OWL, RDF, RDFS
   - `sdo.ttl` - schema.org
   - And many others...

3. **Equivalence Mappings**:
   - `_equivalentclasses.ttl` - Scraped from Wikidata (P1709/P2888 properties)
   - `_manualequivalents.ttl` - Hand-curated mappings to Wikidata entities
   - `_precomputed_equivalences.ttl` - **NEW**: Precomputed equivalence relationships (see Precomputed Equivalences section below)

4. **Project Definitions**:
   - `proto-okn-project.ttl` - Defines the Proto-OKN project and links all T1 graphs using `dct:isPartOf`

### Schema Structure (LinkML-based)

Each TTL file describes a graph's schema using LinkML vocabulary:

```turtle
# Graph/Schema Definition
okns:spoke a linkml:SchemaDefinition ;
    dct:title "SPOKE" ;
    dct:contributor <mailto:email@example.com> ;
    dct:license "https://creativecommons.org/..." ;
    skos:definition "Description of the graph" ;
    linkml:imports okns:other-graph ;  # Dependencies
    linkml:annotations [ ... ] .       # Usage statistics

# Class Definition
okns:Neo4jDisease a linkml:ClassDefinition ;
    skos:inScheme okns:spoke ;         # Belongs to SPOKE
    linkml:class_uri neo4j:Disease ;   # Actual URI in data
    linkml:slots [ ... ] ;             # Properties/predicates
    dct:title "Disease" .

# Slot/Property Definition
okns:neo4j_name a linkml:SlotDefinition ;
    linkml:domain_of okns:Neo4jDisease ;
    linkml:range okns:string ;
    linkml:slot_uri neo4j:name .
```

### Usage Statistics (Counts)

Embedded in the schema annotations:

```turtle
linkml:annotations [
    linkml:tag okns:counts ;
    skos:example [
        linkml:classes [
            skos:example [
                neo4j:Disease [
                    skos:example "153323" ;  # Count of instances
                    linkml:tag neo4j:Disease
                ]
            ]
        ]
    ]
] .
```

## Precomputed Equivalences

**Location**: `docker-backend/_precomputed_equivalences.ttl`

This file contains precomputed equivalence relationships between T1 graphs based on **used classes** (classes that appear in usage statistics), not defined classes.

### Generation

Generated by `analysis/generate_equivalences.py`:
```bash
cd analysis
python3 generate_equivalences.py
```

The script:
1. Queries all used classes across T1 graphs
2. Identifies three types of equivalences:
   - **Shared classes**: Same class URI used in multiple graphs
   - **Direct SKOS**: Classes linked via skos:exactMatch/closeMatch/broadMatch
   - **Wikidata**: Classes linked via Wikidata entities
3. Fetches English labels from Wikidata SPARQL endpoint for Wikidata equivalences
4. Generates reified n-ary relationships with human-readable URIs and rdfs:label

### Structure

Each equivalence is a reified node connecting 2+ graphs:

```turtle
okn:equiv-wikidata-Q515 a okn:WikidataEquivalence ;
    rdfs:label "city" ;  # Fetched from Wikidata
    okn:wikidataEntity <http://www.wikidata.org/entity/Q515> ;
    okn:equivalentClass <http://sail.ua.edu/ruralkg/administrativearea/City> ;
    okn:equivalentClass <http://asu.edu/semantics/SUDOKN/City> ;
    okn:equivalentClass <https://idir.uta.edu/sockg-ontology/docs/City> ;
    okn:inGraph <https://purl.org/okn/schema/ruralkg> ;
    okn:inGraph <https://purl.org/okn/schema/sudokn> ;
    okn:inGraph <https://purl.org/okn/schema/sockg> ;
    okn:usage [
        okn:graph <https://purl.org/okn/schema/ruralkg> ;
        okn:class <http://sail.ua.edu/ruralkg/administrativearea/City> ;
        okn:count 31120
    ] ;
    # ... more usage blocks
```

**Key properties**:
- **rdfs:label**: Human-readable label (e.g., "city", "Shared: Place", "SKOS: Disease")
- **okn:wikidataEntity**: Wikidata URI (for Wikidata equivalences)
- **okn:sharedClass**: Shared class URI (for shared class equivalences)
- **okn:equivalentClass**: Class URIs involved (for direct SKOS and Wikidata)
- **okn:inGraph**: Graphs that use these classes
- **okn:usage**: Individual usage blocks with graph, class, and count

### Statistics (current)

- **18 total equivalences**: 15 shared + 3 Wikidata + 0 direct SKOS
- **Note**: No direct SKOS equivalences found because SKOS relationships exist at schema/metadata level, not in usage statistics

### Frontend Display

The equivalences are loaded automatically on page load via `loadEquivalences()` in App.vue:

```javascript
// Query for equivalences with labels
SELECT ?equiv ?type ?label ?graph WHERE {
  ?equiv a ?type ;
         okn:inGraph ?graph .
  FILTER(?type IN (okn:SharedClassEquivalence, okn:WikidataEquivalence, okn:DirectClassEquivalence))
  optional { ?equiv rdfs:label ?label }
}
```

**Visualization**:
- **Diamond-shaped nodes** (distinguished from circular graph nodes)
- **Colors**: Purple (shared), Hot pink (Wikidata), Light sea green (direct SKOS)
- **Labels**: Show rdfs:label values (e.g., "city", "physical location")
- **Blue bidirectional edges** connect equivalences to related graphs
- **No context menu** on equivalence nodes (only on graph and class nodes)

## Key Prefixes

```sparql
PREFIX dct: <http://purl.org/dc/terms/>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX linkml: <https://w3id.org/linkml/>
PREFIX okn: <https://purl.org/okn/>
PREFIX okns: <https://purl.org/okn/schema/>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
```

## SPARQL Queries

### Query 0: loadProtoOKNGraphs (Initial Load)
**Purpose**: Load all graphs that are part of the Proto-OKN project on page load

**When**: Automatically when the page loads

```sparql
SELECT ?graph ?graphLabel WHERE {
  ?graph dct:isPartOf okn:proto-okn ;
         a linkml:SchemaDefinition .
  optional { ?graph dct:title ?graphLabel }
}
```

**Result**: Returns all 16 T1 graphs that are members of the Proto-OKN project. These are displayed with the fcose layout algorithm.

**Implementation Notes**:
- Called in `App.vue` after Cytoscape initialization
- Config must be loaded first to ensure SPARQL endpoint is set
- Nodes are added dynamically with classes: `['graph','collapsed','importsMissing', shrunkGraphId]`

### Query 1: getDefinedClasses
**Purpose**: Show classes defined within a graph (internal classes)

**When**: Right-click graph → "Show defined classes"

```sparql
SELECT distinct ?class ?classLabel WHERE {
  ?class a linkml:ClassDefinition ;
         skos:inScheme okns:spoke ;           # Filter to this graph
         linkml:class_uri ?classuri .
  # Only show classes that have actual usage/instances
  [] linkml:tag okns:counts ;
     skos:example [ linkml:classes [ skos:example [ ?classuri [] ] ] ]
  optional { ?class dct:title ?classLabel }
} limit 10
```

**Result for SPOKE**: Returns 6 classes (Neo4jDisease, Neo4jCompound, Neo4jOrganism, Neo4jEnvironment, Neo4jLocation, Neo4jSDoH)

### Query 2: getAllUsedClasses
**Purpose**: Show which classes appear in a graph's usage statistics

**When**: Right-click graph → "Show used classes"

```sparql
SELECT ?graph ?graphLabel ?class ?classLabel ?count WHERE {
  # Navigate to the counts section
  okns:spoke linkml:annotations [
    linkml:tag okns:counts ;
    skos:example/linkml:classes/skos:example [ ?class_ ?s ]
  ] .

  # Find which graph defines each class
  ?class a linkml:ClassDefinition ;
         linkml:class_uri ?class_ ;
         skos:inScheme ?graph .

  optional { ?graph dct:title ?graphLabel }
  optional { ?class dct:title ?classLabel }

  # Extract the count
  ?s ?p ?count .
  filter(?p = skos:example)
} limit 10
```

**Behavior**:
- Returns all classes found in usage counts (both internal and external)
- JavaScript filters out internal classes (where `?graph == okns:spoke`)
- Only draws edges for external classes

**Note**: This query can be confusing - it returns both internal and external classes, but the visualization only shows relationships to external ones.

### Query 3: getEquivalentClasses (Single Class)
**Purpose**: Find semantically equivalent classes for ONE specific class

**When**: Right-click on a class node (red dot) → "Show equivalent classes"

```sparql
SELECT ?class ?classLabel ?graph ?graphLabel WHERE {
  # Two paths to find equivalences:

  # Path A: Direct SKOS mappings
  { okns:Neo4jDisease skos:exactMatch|skos:closeMatch|skos:broadMatch ?class_ }

  union

  # Path B: Transitive through Wikidata
  {
    okns:Neo4jDisease linkml:class_uri ?c1_ .
    # ^skos:exactMatch means "reverse direction" - find things that point TO this URI
    ?c1_ ^skos:exactMatch/skos:exactMatch ?class_
  }

  # Find which graph defines the equivalent class
  ?class a linkml:ClassDefinition ;
         linkml:class_uri ?class_ ;
         skos:inScheme ?graph .

  optional { ?class dct:title ?classLabel }
  optional { ?graph dct:title ?graphLabel }
} limit 10
```

**Path B Explanation** (Transitive via Wikidata):
```
okns:Neo4jDisease → neo4j:Disease ← wd:Q12136 → mondo:Disease
                    (class URI)    (Wikidata)   (MONDO URI)
```

The `^` operator reverses the direction, so:
- `A ^skos:exactMatch` means "find things that have `skos:exactMatch A`"
- This allows traversing through Wikidata entities that link multiple ontologies

### Query 3b: getAllEquivalentClasses (All Classes in Graph)
**Purpose**: Find equivalences for ALL classes in a graph at once

**When**: Right-click graph → "Show equivalent classes"

```sparql
SELECT ?c1 ?c1Label ?class ?classLabel ?graph ?graphLabel WHERE {
  # Find all classes in this graph
  ?c1 skos:inScheme okns:spoke .

  # Same two paths as Query 3
  { ?c1 skos:exactMatch|skos:closeMatch|skos:broadMatch ?class_ }
  union
  { ?c1 linkml:class_uri ?c1_ .
    ?c1_ ^skos:exactMatch/skos:exactMatch ?class_ }

  # Find the external graph (filter out self)
  ?class linkml:class_uri ?class_ ;
         skos:inScheme ?graph .
  filter(?graph != okns:spoke)

  optional { ?class dct:title ?classLabel }
  optional { ?graph dct:title ?graphLabel }
} limit 10
```

**Graphs with equivalences**:
- schema.org (sdo): 350 equivalences
- SPOKE: 14 equivalences
- NIKG, Wildlife-KN: 8 each
- DREAM-KG: 0 (no equivalences)

### Query 4: getGraphImports
**Purpose**: Show dependency relationships between graphs

**When**: Right-click graph → "Show graph dependencies"

```sparql
SELECT ?s ?sLabel ?o ?oLabel WHERE {
  VALUES ?s { okns:biobricks-ice }
  ?s linkml:imports ?o .
  # Commented out: minus { ?s linkml:imports ?p . ?p linkml:imports+ ?o }
  # (Would filter to direct imports only, excluding transitive)
  optional { ?s dct:title ?sLabel }
  optional { ?o dct:title ?oLabel }
} limit 100
```

**Result**: Green arrows showing import relationships

## Visualization Behavior

### Edge Types (Colors)
- **Green arrows** (`import`): Graph A imports/depends on Graph B
- **Blue bidirectional arrows** (`equivalent`): Classes are semantically equivalent
- **Orange arrows with counts** (`classuse`): Graph A uses N instances of a class from Graph B

### Node Types
- **Black dots**: T1 graphs (all 16 Proto-OKN graphs loaded dynamically)
- **Gray dots**: External ontologies (added when exploring dependencies)
- **Red dots inside graphs**: Class definitions (when expanded)
- **Diamond shapes**: Equivalence nodes (purple=shared, hot pink=Wikidata, light sea green=SKOS)

### Initial State (Dynamic)
The initial visualization is dynamically loaded from the triple store:
- All graphs with `dct:isPartOf okn:proto-okn` are queried on page load
- All precomputed equivalences are loaded and displayed as diamond nodes
- Nodes are positioned using the fcose (force-directed) layout algorithm
- No hardcoded graph lists - all data comes from SPARQL queries

### User Interactions
- **Click on any node**: Shows entity details in right sidebar
- **No context menu**: The right-click context menu has been completely removed from all nodes

## Running the System

**IMPORTANT**: We ALWAYS use Docker for both backend and frontend. Do NOT use `npm run dev` or `npm run build` directly.

### Backend (Triple Store)

```bash
cd docker-backend
docker build -t okn-triplestore .
docker run -p 8000:8000 okn-triplestore
```

**Test the endpoint**:
```bash
curl -G http://localhost:8000 \
  --data-urlencode "query=SELECT ?s ?p ?o WHERE { ?s ?p ?o } LIMIT 5"
```

### Frontend (Vue App)

```bash
docker build -f docker-frontend/Dockerfile -t okn-frontend .
docker run -p 8080:8080 \
  -e API_URL=http://localhost:8000 \
  okn-frontend
```

Access at: **`http://localhost:8080`**

**Note**: When making frontend changes, always rebuild the Docker image.

### Configuration

The frontend loads `config.json` to get the SPARQL endpoint URL before initializing:
```javascript
// App.vue - loadConfig function
const oknSparqlEndpoint = ref("http://localhost:8000")

async function loadConfig(){
  try {
    let response = await fetch("/config.json");
    const config = await response.json();
    oknSparqlEndpoint.value = config.sparqlEndpoint;
  } catch (e) {
    // Falls back to localhost:8000
  }
}

// In onMounted - load config FIRST, then initialize
onMounted(async () => {
  await loadConfig()  // Ensures endpoint is set before queries run
  cyc.value = cytoscape({ ... })
  loadProtoOKNGraphs()  // Now safe to query
})
```

**Important**: Config must be loaded before Cytoscape initialization to ensure the SPARQL endpoint is set before any queries run.

## Data Generation

### For Individual Graphs

1. Generate LinkML schema (in separate `schema-gen` repo):
   ```bash
   # See https://github.com/frink-okn/schema-gen
   ```

2. Convert schema to RDF:
   ```bash
   python3 src/rdfgen-frink.py your-graph.yaml > docker-backend/your-graph.ttl
   ```

### For Equivalence Files

- **`_manualequivalents.ttl`**: Hand-curated file mapping Wikidata entities to graph URIs
- **`_equivalentclasses.ttl`**: Generated by querying Wikidata (script not published)

Both files provide `skos:exactMatch` statements that link classes across graphs via Wikidata as a bridge.

## Analysis Tools

**Location**: `analysis/` directory

### Class Usage Analysis

Analyzes patterns of class definition vs. usage across T1 graphs:

```bash
cd analysis
./run_queries.sh                  # Queries triple store for defined/used classes
python3 analyze_class_usage.py    # Analyzes and reports patterns
```

**Output**: Identifies classes that are:
1. Both defined AND used (internal usage)
2. Defined but NOT used (unused schema elements)
3. Used but NOT defined (external dependencies)

See `analysis/README.md` for full documentation.

### Equivalence Generation

Generates the precomputed equivalences file:

```bash
cd analysis
python3 generate_equivalences.py  # Queries triple store and Wikidata, generates TTL
```

**Important**:
- Queries Wikidata's SPARQL endpoint for English labels
- May take a minute to complete due to external API calls
- Output: `docker-backend/_precomputed_equivalences.ttl`
- After regenerating, rebuild the backend Docker image to load new data

## Key Files

- `src/App.vue` - Main application component with all queries and visualization logic
- `src/prefixes.js` - RDF prefix definitions for shrinking/expanding URIs
- `vite.config.ts` - Build configuration (note `base: "/okn-map/"`)
- `docker-backend/Dockerfile` - Backend triple store container
- `docker-frontend/Dockerfile` - Frontend nginx container
- `docker-backend/*.ttl` - All RDF data files
- `docker-backend/_precomputed_equivalences.ttl` - Precomputed equivalence relationships
- `analysis/generate_equivalences.py` - Script to regenerate equivalences
- `analysis/analyze_class_usage.py` - Script to analyze class usage patterns

## Known Issues / TODOs

1. **Empty results handling**: UI appears to "hang" when queries return no results (e.g., DREAM-KG equivalences)
2. **Query 2 naming**: `getAllUsedClasses` is misleading - it returns all classes but only visualizes external ones
3. **Node styling**: All graphs currently display as black dots - could restore use case color coding by querying additional metadata
4. **Legacy query functions**: The old right-click menu functions (getDefinedClasses, getAllUsedClasses, etc.) still exist in App.vue but are not accessible since the context menu was removed. These could be removed or repurposed for future features.

## Tips for Development

1. **Use dev mode** (`npm run dev`) - much easier than Docker for frontend development
2. **Check browser console** for SPARQL query debugging (queries are logged)
3. **Test queries directly** via curl against `http://localhost:8000` before debugging UI
4. **Graphs with best test data**:
   - SPOKE: Has defined classes, used classes, and equivalences
   - BioBricks-ICE: Has imports and external class usage
   - DREAM-KG: Has classes but NO equivalences (good for testing empty results)

## For Creating a Fork/Variant

To create a parallel system with subset data and different UI:

1. **Keep the same stack**:
   - Backend: rdflib-endpoint with TTL files
   - Frontend: Vue 3 + Vite + Cytoscape.js
   - Container setup similar to current

2. **Data subset**:
   - Copy relevant TTL files to your fork's `docker-backend/`
   - Optionally transform/filter the triples
   - Keep the LinkML schema structure or adapt as needed

3. **UI modifications**:
   - Fork `src/App.vue` and modify queries/visualization
   - Adjust `vite.config.ts` base path if needed
   - Update hardcoded graph lists or make them query-based

4. **Docker setup**:
   - Same Dockerfile pattern for backend (rdflib-endpoint)
   - Frontend Dockerfile may need path fixes (or use dev mode)

The architecture is fairly modular - backend just serves SPARQL, frontend just queries and visualizes. You can swap out either side independently.
